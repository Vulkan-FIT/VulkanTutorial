<!DOCTYPE html>
<html lang=”en” manifest="/cache.appcache">
<head>
<title>01-DeviceList</title>
<meta charset="utf-8">
<link rel="stylesheet" rel="noopener" target="_blank" href="bootstrap/css/bootstrap.min.css"> <!-- This link is only necessary if you’re using an external stylesheet -->
<style>
/* These style tags are only necessary if you’re adding internal CSS */
</style>
</head>
<body>

<h1>Vulkan Tutorial</h1>

<h2>01-DeviceList</h2>
  
<p>Vulkan is a low-level, low-overhead API for 3D graphics and computing. Currently, it is one of the most important APIs in its area.</p>

<details><summary>Vulkan history and design</summary>

<p>Vulkan 1.0 was released in 2016. It is almost 25 years after the first version of OpenGL.
On the beginning of 90', graphics cards were - if we simplify it - only a piece of memory with monitor output.
Whatever was written to the memory appeared on the screen. Today in 2024, a main stream graphics card is programmable, massively parallel compute unit.
When comparing computing power, it might outperform tens, hundreds, or even thousands of traditional processors in extreme cases.
Vulkan is designed with the focus on effective use of the performance potential that is hidden in the graphics cards of today.</p>

<p>The other view: 25 years before Vulkan 1.0, almost all computers had only one processor capable of executing a single thread at a time.
This corresponds to a single active OpenGL context per thread. This was logical design for these old times, but it does not fit well in our reality.
Today, standard computer contains multi-core processor capable of executing many threads simultaneously.
Executing of tens of threads in parallel is not an exception.
No wonder that Vulkan is designed to be able to take advantage of multi-threaded programming and parallel processing by many cores of the processor.
And not only multi-core processing is in Vulkan design focus, but also multiple graphics cards can be handled by Vulkan natively.</p>

<p>OpenGL has high overhead for some operations and its driver is very complex.
On the other side, Vulkan is low-level API with low overhead and relatively simple driver.
Simple driver usually results in much less driver bugs and better driver and system stability.</p>

<p>OpenGL is platform neutral, but faced difficulties anyway. On macOS, it was always number of versions behind the standard.
On mobile devices, usually only OpenGL ES was supported.
When looking on Vulkan, it is supported on macOS (through MoltenVk) and majority of modern tablets and mobile phones.</p>

</details>

<p>Vulkan is amazing by its low-level approach, because we can work very effectively with underlying hardware and optimize our code in many details.
However, it has also its downsides. Few lines of OpenGL code might need tens or even hundreds lines of code when using Vulkan.
Low-level Vulkan code brings new flexibility. But many programmers might feel unprepared to deal with such amount of low-level code and to understand it.
And that is where this tutorial makes an attempt to help and tries to introduce a programmer into basics of Vulkan programming.</p>

<p>In our tutorial, we will use modern C++20 or newer. Normally, we would use
<a href="https://github.com/KhronosGroup/Vulkan-Hpp">Vulkan-Hpp</a> as C++ Vulkan binding.
However, Vulkan-Hpp has some design limitations that advanced user might reach from time to time, but most importantly,
the current version 1.3.283 takes about quarter of million lines of code that must be included and processed by the compiler.
It takes roughly about 3-4 seconds to process such large headers by a modern processor of today.
Another Vulkan-Hpp limitation is memory overhead of Unique_* and raii classes. Both issues are solved by vkg Vulkan binding.
Vkg means Vulkan generated. Being generated, its another advantage is that not used parts of the API can be switched off
and they will not be present in vkg.h and vkg.cpp.
This, in turn, results in a smaller API, a little smaller output binary, and usually less function pointers which in turn
results in a little better cache effectivity.</p>

<p>Now a little controversial thing: C++ exceptions. While not being expert, my experiments show that using exceptions
results in higher application performance and make code more simple and readable. The reason seems to be simple:
The use of exceptions removes much of the error handling routines from our code with the result
of making code faster and more readable. Instead of the error handling code, many compilers create tables that control
the process of exception handling. In other words, the error handling functionality is moved from code into tables,
making our code faster and cleaner. The tables might make executables a little bigger, some say by 20%,
but what usually matters is performance.</p>

<p>Other people might argue that raising exception is very slow, thus they shall not be used.
My opinion is following: exception is related to the word exceptional. So, it is raised in exceptional situations
like write failed because disk is full or Vulkan command failed because operating system restarted GPU driver.
Such situations may an application handle by showing message dialog and by terminating the application.
Who cares that the message dialog appeared few microseconds later?
The system will probably wait couple of seconds anyway before the user clicks Ok.
Or, who cares that an application termination took couple of microseconds more?
What usually interests us is application performance and code readability,
not the handling of exceptional circumstances that are often handled by application termination
or other serious actions.</p>


<h2>The first application: Instance and listing of physical devices</h2>

<p>Our first Vulkan application will print names of all Vulkan physical devices installed in the given system.
We will do it in five steps:</p>
<ol><item>vk::loadLib() - loads Vulkan library</item>
<item>vk::createInstance() - creates global Vulkan instance object</item>
<item>vk::enumeratePhysicalDevices() - get list of physical devices</item>
<item>vk::getPhysicalDeviceProperties() - get properties of each physical device</item>
<item>print device name</item></ol>

<p>And we have to wrap our code to catch exceptions if one is raised:</p>

<pre>
int main(int, char**)
{
	// catch exceptions
	// (vk functions throw if they fail)
	try {

		// load Vulkan library
		vk::loadLib();

		// Vulkan instance
		vk::createInstance(
			vk::InstanceCreateInfo{
				.sType = vk::STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO,
				.pNext = nullptr,
				.flags = 0,
				.pApplicationInfo =
					&(const vk::ApplicationInfo&)vk::ApplicationInfo{
						.sType = vk::STRUCTURE_TYPE_APPLICATION_INFO,
						.pNext = nullptr,
						.pApplicationName = "01-deviceList",
						.applicationVersion = 0,
						.pEngineName = nullptr,
						.engineVersion = 0,
						.apiVersion = vk::apiVersion1_0,
					},
				.enabledLayerCount = 0,
				.ppEnabledLayerNames = nullptr,
				.enabledExtensionCount = 0,
				.ppEnabledExtensionNames = nullptr,
			});

		// print device list
		vk::Vector<vk::PhysicalDevice> deviceList = vk::enumeratePhysicalDevices();
		cout << "Physical devices:" << endl;
		for(size_t i=0; i<deviceList.size(); i++) {
			vk::PhysicalDeviceProperties p = vk::getPhysicalDeviceProperties(deviceList[i]);
			cout << "   " << p.deviceName << endl;
		}

	// catch exceptions
	} catch(vk::Error& e) {
		cout << "Failed because of Vulkan exception: " << e.what() << endl;
	} catch(exception& e) {
		cout << "Failed because of exception: " << e.what() << endl;
	} catch(...) {
		cout << "Failed because of unspecified exception." << endl;
	}

	return 0;
}
</pre>

</body>
</html>
