<!DOCTYPE html>
<html lang=”en” manifest="/cache.appcache">
<head>
<title>01-DeviceList</title>
<meta charset="utf-8">
<link rel="stylesheet" rel="noopener" target="_blank" href="bootstrap/css/bootstrap.min.css"> <!-- This link is only necessary if you’re using an external stylesheet -->
<style>
/* These style tags are only necessary if you’re adding internal CSS */
</style>
</head>
<body>

<h1>Vulkan Tutorial</h1>

<h2>01-DeviceList</h2>
  
<p>Vulkan is a low-level, low-overhead API for 3D graphics and computing. Currently, it is one of the most important APIs in its area.</p>

<details><summary>Vulkan history and design</summary>

<p>Vulkan 1.0 was released in 2016. It is almost 25 years after the first version of OpenGL.
On the beginning of 90', graphics cards were - if we simplify it - only a piece of memory with monitor output.
Whatever was written to the memory appeared on the screen. Today in 2024, a main stream graphics card is programmable, massively parallel compute unit.
When comparing computing power, it might outperform tens, hundreds, or even thousands of traditional processors in extreme cases.
Vulkan is designed with the focus on effective use of the performance potential that is hidden in the graphics cards of today.</p>

<p>The other view: 25 years before Vulkan 1.0, almost all computers had only one processor capable of executing a single thread at a time.
This corresponds to a single active OpenGL context per thread. This was logical design for these old times, but it does not fit well in our reality.
Today, standard computer contains multi-core processor capable of executing many threads simultaneously.
Executing of tens of threads in parallel is not an exception.
No wonder that Vulkan is designed to be able to take advantage of multi-threaded programming and parallel processing by many cores of the processor.
And not only multi-core processing is in Vulkan design focus, but also multiple graphics cards can be handled by Vulkan natively.</p>

<p>OpenGL has high overhead for some operations and its driver is very complex.
On the other side, Vulkan is low-level API with low overhead and relatively simple driver.
Simple driver usually results in much less driver bugs and better driver and system stability.</p>

<p>OpenGL is platform neutral, but faced difficulties anyway. On macOS, it was always number of versions behind the standard.
On mobile devices, usually only OpenGL ES was supported.
When looking on Vulkan, it is supported on macOS (through MoltenVk) and majority of modern tablets and mobile phones.</p>

</details>

<p>Vulkan is amazing by its low-level approach, because we can work very effectively with underlying hardware and optimize our code into the details.
However, it has also its downsides. Few lines of OpenGL code might need tens or even hundreds lines of code when using Vulkan.
Low-level Vulkan code brings new flexibility. But you might feel unprepared to deal with such amount of low-level code and to understand it.
And that is where this tutorial makes an attempt to help and tries to introduce a programmer into basics of Vulkan programming.</p>

<p>In our tutorial, we will use modern C++20 or newer. Normally, we would use Vulkan-Hpp as C++ Vulkan binding.
However, Vulkan-Hpp has some design limitations that advanced user might reach from time to time, but most importantly,
the current version 1.3.283 takes about quarter of million lines of code that must be included and processed by the compiler.
It takes roughly about 3-4 seconds to process such large headers by a modern processor of today. </p>
  
</body>
</html>
